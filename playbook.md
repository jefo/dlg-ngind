# Roadmap: от "Руин" до "Greeter Bot"

Этот документ описывает пошаговый план реализации сквозного сценария "Greeter Bot" в контексте `@bot-persona`. Каждый шаг представляет собой атомарную задачу с конкретным артефактом на выходе.

---

### Шаг 1: Укрепление фундамента (Домен `Design`)

-   **Цель:** Привести в порядок и финализировать доменные объекты, описывающие "чертеж" бота. Без прочного фундамента любой use case будет стоять на песке.
-   **Инвентаризация:**
    -   `form.entity.ts`: **Готово.** Мы его переписали в стиле `sotajs`.
    -   `bot-persona.aggregate.ts`: **Готово.** Мы его также переписали.
    -   `fsm.entity.ts` и `view.entity.ts`: Существуют, но, скорее всего, требуют рефакторинга, аналогичного `form.entity.ts`, чтобы стать полноценными `sotajs`-сущностями со своими схемами и `actions`.
-   **Действие:**
    1.  **Реализовать `fsm.entity.ts`:** Переписать в виде `createEntity`, определить `FsmDefinitionSchema` и экспортировать его.
    2.  **Реализовать `view.entity.ts`:** Аналогично переписать в виде `createEntity` с `ViewDefinitionSchema`.
    3.  **Проверить `bot-persona.aggregate.ts`:** Убедиться, что он корректно импортирует и использует схемы из обновленных `fsm.entity` и `view.entity`.
-   **Артефакт на выходе:** Папка `packages/bot-persona/src/desing/domain/` содержит 4 полностью согласованных, реализованных в стиле `sotajs` доменных файла. **Результат:** у нас есть надежный способ создавать в памяти валидные "чертежи" ботов.

---

### Шаг 2: Создание "Конструктора" (Use Case `Design`)

-   **Цель:** Реализовать use case, который позволит системе принимать и сохранять определения ботов.
-   **Инвентаризация:**
    -   `define-bot-persona.use-case.ts`: Существует, но код внутри (`defineBotPersonaCommand`) выглядит устаревшим.
-   **Действие:**
    1.  **Переписать `define-bot-persona.use-case.ts` с нуля.**
    2.  Определить четкий входной DTO, например `DefineBotPersonaInput`, который будет содержать `name`, `fsmDefinition`, `viewDefinition`, `formDefinition`.
    3.  Внутри use case:
        -   Вызвать `BotPersona.create()` с входными данными. Это атомарно проверит все инварианты.
        -   При успехе — вызвать `saveBotPersonaPort` для сохранения чистого состояния (`.state`).
        -   При ошибке (нарушении инвариантов) — вызвать выходной порт `operationFailedOutPort`.
-   **Артефакт на выходе:** Рабочий use case, который можно вызвать, чтобы определить и сохранить нашего "Greeter Bot". **Результат:** мы можем программно создавать и сохранять "личности" ботов.

---

### Шаг 3: Укрепление второго фундамента (Домен `Runtime`)

-   **Цель:** Создать надежный агрегат `Conversation`, который будет управлять состоянием *одного конкретного* диалога.
-   **Инвентаризация:**
    -   `conversaton.aggregate.ts`: Существует, но выглядит переусложненным, смешивает в себе логику FSM и другие задачи.
-   **Действие:**
    1.  **Переписать `conversation.aggregate.ts` с нуля.**
    2.  **Упростить состояние:** Схема агрегата должна содержать только динамические данные: `id`, `botPersonaId`, `chatId`, `status`, `currentStateId` и `formState` (состояние полей формы). **Важно:** он не должен хранить в себе копии FSM или View.
    3.  **Реализовать `actions`:**
        -   `applyEvent({ event, payload })`: Главный метод. Он не содержит логики FSM, а лишь обновляет `currentStateId` и `formState` на основе *уже принятого решения*, которое будет вычислено в use case.
        -   `finish()`: Завершает диалог.
-   **Артефакт на выходе:** Легковесный и сфокусированный агрегат `Conversation`, отвечающий только за хранение состояния живого диалога. **Результат:** у нас есть надежный способ управлять состоянием активного диалога.

---

### Шаг 4: Запуск диалога (Use Case `Runtime`)

-   **Цель:** Реализовать use case, который "оживляет" чертеж бота для конкретного пользователя.
-   **Инвентаризация:**
    -   `start-conversation.use-case.ts`: Существует, но, вероятно, пуст.
-   **Действие:**
    1.  **Реализовать логику use case:**
        -   Принять на вход `{ botPersonaId, chatId }`.
        -   Загрузить `BotPersona` через `findBotPersonaByIdPort`.
        -   Создать новый `Conversation`, используя `id` загруженного `BotPersona` и `chatId`. Начальное состояние взять из `persona.state.fsmDefinition.initialStateId`.
        -   Сохранить `Conversation` через `saveConversationPort`.
        -   Сформировать DTO для рендеринга (взяв `component` и `props` из `persona.state.viewDefinition` для начального состояния) и вызвать `componentRenderOutPort`.
-   **Артефакт на выходе:** Рабочий use case, который начинает диалог и отправляет пользователю первое сообщение. **Результат:** мы можем инициировать диалог.

---

### Шаг 5: Обработка ответа пользователя (Use Case `Runtime`)

-   **Цель:** Реализовать ключевой use case, который двигает диалог вперед.
-   **Инвентаризация:**
    -   `process-user-input.use-case.ts`: Скорее всего, отсутствует.
-   **Действие:**
    1.  **Создать и реализовать `process-user-input.use-case.ts`:**
        -   Принять на вход `{ chatId, event, payload }`.
        -   Загрузить `Conversation` и связанный с ним `BotPersona`.
        -   Используя `FSM` из `BotPersona`, вычислить следующий шаг (`nextStateId` и данные для `assign`).
        -   Вызвать `conversation.actions.applyEvent(...)` с результатом вычислений.
        -   Сохранить обновленный `Conversation`.
        -   Сформировать DTO для рендеринга нового состояния и вызвать `componentRenderOutPort`.
-   **Артефакт на выходе:** Рабочий use case, обрабатывающий ввод пользователя. **Результат:** диалог становится интерактивным.

---

### Шаг 6: Сборка и сквозной тест

-   **Цель:** Убедиться, что все шаги работают вместе как единое целое.
-   **Инвентаризация:**
    -   `composition.ts`: Файл для связывания портов и адаптеров.
    -   `run-test.ts`: Пример запуска.
-   **Действие:**
    1.  **Актуализировать `composition.ts`:** Прописать все необходимые `setPortAdapter` для новых и обновленных портов.
    2.  **Создать `e2e-greeter-bot.ts`:** Написать скрипт, который последовательно:
        -   Вызывает `DefineBotPersonaUseCase` с определением "Greeter Bot".
        -   Вызывает `StartConversationUseCase`.
        -   Эмулирует ответы пользователя, вызывая `ProcessUserInputUseCase`.
        -   Проверяет по логам `console.presenter`, что бот отвечает корректно на каждом шаге.
-   **Артефакт на выходе:** Исполняемый скрипт, который демонстрирует полный, работающий сценарий "Greeter Bot". **Результат:** мы достигли тактической цели.
