# Архитектура Use Case: ProcessUserInput

Этот документ описывает архитектурные требования и проектное решение для ключевого use case в рантайм-контексте диалогового движка — `ProcessUserInputUseCase`. Дизайн основан на принципах SOLID, DDD и Гексагональной/Чистой архитектуры.

---

### Бизнес-цель

Обработать одно действие пользователя (ввод текста, нажатие кнопки) в рамках существующего диалога, перевести диалог в новое состояние и предоставить пользователю соответствующий отклик.

### Детализированные Требования

1.  **Идентификация Диалога:**
    -   Use case должен получить на вход `chatId` для однозначной идентификации диалога.
    -   Он обязан найти **активный** диалог, связанный с этим `chatId`.
    -   **Исход "Не найдено":** Если активный диалог не найден, use case должен завершить работу, уведомив систему через специальный выходной порт `conversationNotFoundOutPort`.

2.  **Обработка Ввода:**
    -   Use case должен принимать `event` (строка, описывающая действие, например, `SUBMIT_NAME`) и опциональный `payload` (объект с данными, например, `{ name: 'Иван' }`).

3.  **Делегирование Бизнес-Логики:**
    -   Use case **не должен содержать** логику конечного автомата (FSM).
    -   Он должен вызвать метод на загруженном агрегате `Conversation` (например, `applyEvent`), передав ему `event` и `payload`. Вся логика перехода, обновления данных формы (`assign`) и изменения статуса инкапсулирована внутри агрегата.

4.  **Обработка Ошибок Бизнес-Логики:**
    -   **Исход "Невалидное событие":** Если агрегат `Conversation` выбрасывает исключение (например, потому что событие `event` недопустимо в текущем состоянии), use case должен перехватить его и уведомить систему через порт `invalidInputOutPort`.

5.  **Сохранение Состояния:**
    -   После успешного выполнения метода на агрегате, use case должен сохранить измененное состояние `Conversation` через `saveConversationPort`.

6.  **Отправка Отклика Пользователю:**
    -   После сохранения, use case должен запросить у агрегата `Conversation` актуальное представление (`currentView`).
    -   Это представление (имя компонента и его `props`) должно быть отправлено в выходной порт `componentRenderOutPort`.

7.  **Обработка Завершения Диалога:**
    -   Если в результате `applyEvent` диалог перешел в статус `finished`, use case должен дополнительно уведомить систему через порт `conversationFinishedOutPort`.

---

### Архитектура с соблюдением SOLID

Чтобы удовлетворить этим требованиям, мы построим архитектуру из следующих компонентов:

1.  **`ProcessUserInputUseCase` (Оркестратор):**
    -   **Ответственность (S):** Только оркестрация. Его единственная задача — координировать взаимодействие между портами и агрегатом. Он не знает, как работает FSM, как сохраняются данные или как они рендерятся.
    -   **Зависимости (D):** Зависит только от абстракций (портов), а не от конкретных реализаций.

2.  **Агрегат `Conversation` (Эксперт по Домену):**
    -   **Ответственность (S):** Инкапсулирует всю бизнес-логику и правила одного диалога. Знает всё о своих состояниях, переходах и данных.
    -   **Поведение:** Предоставляет "умный" метод `applyEvent`, который является фасадом для всей сложной внутренней логики.

3.  **Порты (Абстракции/Контракты):**
    -   **Принцип (I):** Каждый порт имеет узкую, специфичную задачу (`find...`, `save...`, `render...`). Мы не создаем один большой "порт для всего".
    -   **Принцип (D):** Являются точкой инверсии зависимостей.

4.  **Адаптеры (Конкретные Реализации):**
    -   **Принцип (O):** Систему легко расширить, добавив новые адаптеры (например, `PostgresAdapter` или `RenderToVoiceAdapter`), не изменяя при этом use case или домен.
    -   **Принцип (L):** Любой адаптер, реализующий порт, взаимозаменяем. `InMemoryAdapter` можно безболезненно заменить на `MongoDbAdapter`.

#### Поток управления (Flow of Control)

1.  Внешняя система (например, `chat` контекст) вызывает `ProcessUserInputUseCase` с `{ chatId, event, payload }`.
2.  **Use Case** вызывает `usePort` для получения реализаций нужных ему портов.
3.  **Use Case** -> `findActiveConversationByChatIdPort` -> **Persistence Adapter** находит и возвращает агрегат `Conversation`.
4.  **Use Case** вызывает метод `conversation.actions.applyEvent({ event, payload })`.
5.  **Агрегат `Conversation`** выполняет всю бизнес-логику: проверяет переход, меняет `currentStateId`, обновляет `formState`.
6.  **Use Case** -> `saveConversationPort` -> **Persistence Adapter** сохраняет измененное состояние агрегата.
7.  **Use Case** запрашивает вычисляемое свойство `conversation.currentView`.
8.  **Use Case** -> `componentRenderOutPort` -> **Presenter Adapter** получает готовые данные и рендерит их (например, выводит в консоль).
9.  (Если применимо) **Use Case** -> `conversationFinishedOutPort` -> **Adapter** уведомляет систему о завершении диалога.

Эта архитектура полностью соответствует принципам SOLID, обеспечивая слабую связанность, высокую тестируемость и гибкость для будущего расширения.