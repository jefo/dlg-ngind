
# Контекст проекта: `bot-persona`

Этот документ описывает архитектуру, текущее состояние и цели пакета `bot-persona`.

## 1. О нас: Кто мы и что мы строим?

Мы создаем **`bot-persona`** — движок (SDK) для построения диалоговых ботов.

Ключевая цель — предоставить инструмент, который позволит пользователям (разработчикам) определять поведение ботов через декларативные сценарии. Эти сценарии в будущем будут создаваться в **no-code/low-code конструкторе**.

В основе нашей философии лежат:
- **DDD (Domain-Driven Design)**: Мы моделируем предметную область через Агрегаты, Сущности и Объекты-значения.
- **Гексагональная архитектура (Порты и Адаптеры)**: Наша бизнес-логика (домен и приложение) не зависит от внешних сервисов (БД, UI). Взаимодействие происходит через четко определенные порты.
- **Фреймворк SotaJS**: Мы используем `@maxdev1/sotajs` как основу для реализации DDD и DI (Dependency Injection).

## 2. Где мы сейчас: Ключевые архитектурные решения

Наша архитектура четко разделяет **Определение (Definition)** бота от его **Исполнения (Runtime)**.

### Уровень Определения (Definition)

- **`BotPersona` (Агрегат)**: Это "шаблон" или "личность" бота. Он является транзакционной границей и объединяет в себе статичные определения:
    - **`fsmDefinition` (FsmEntity)**: Декларативное описание состояний и переходов конечного автомата (FSM), которое задает логику диалога.
    - **`viewDefinition` (ViewEntity)**: Карта представлений, которая сопоставляет состояния FSM с UI-компонентами и их `props`.
    - **`formSchema` (JSON Schema)**: Схема для валидации данных, собираемых в ходе диалога, с использованием `ajv`.

### Уровень Исполнения (Runtime)

- **`Conversation` (Агрегат)**: Это живой экземпляр диалога для конкретного пользователя (`chatId`). Он хранит динамическое состояние:
    - `currentStateId`: Текущее состояние в FSM.
    - `formState`: Контекст беседы — данные, собранные от пользователя (`{ "userName": "Иван", "age": 30 }`).
    - `status`: Жизненный цикл диалога (`active`, `finished`).

### Ключевые Доменные Объекты

- **`FSM` (Value Object)**: Неизменяемый объект, инкапсулирующий чистую логику FSM. Он ничего не знает о контексте, его задача — валидировать переходы (`canTransition`, `nextState`).
- **`ViewMap` (Value Object)**: Неизменяемый объект-словарь, сопоставляющий состояния FSM с компонентами.
- **`Form` (Entity)**: Сущность, отвечающая за сбор и валидацию полей формы в рамках одного диалога.

### Поток управления (SotaJS)

Мы следуем "inside-out" подходу:
1.  **Use Cases** (`@application/use-cases`): Оркестрируют бизнес-процессы (`defineBotPersona`, `startConversation`, `processUserInput`). Они принимают команды, взаимодействуют с портами и вызывают доменную логику.
2.  **Порты** (`@domain/ports`, `@application/ports`): Абстрактные контракты.
    - *Порты данных* (`saveConversationPort`) используются для персистенции.
    - *Выходные порты* (`componentRenderOutPort`, `invalidInputOutPort`) используются для уведомления внешнего мира о результате, что делает use cases независимыми от UI.
3.  **Адаптеры** (`@infrastructure`): Конкретные реализации портов. Сейчас мы используем `in-memory` адаптеры для хранения и `console` презентеры для вывода.
4.  **Composition Root** (`composition.ts`): Точка сборки приложения, где порты связываются с адаптерами.

## 3. Куда мы идем: Следующие шаги и цели

1.  **Стабилизация Агрегата `Conversation`**: Мы работаем над тем, чтобы его структура была максимально "элегантной" — чтобы он полностью инкапсулировал логику управления состоянием диалога (`nextStep`, `finish`), при этом оставаясь чистым с точки зрения DDD.

2.  **Поддержка no-code конструктора**: Вся наша архитектура определений (`FSM`, `ViewMap`, `formSchema`) спроектирована так, чтобы быть полностью **JSON-сериализуемой**. Это фундамент для визуального редактора, который будет генерировать эти JSON-определения.

3.  **Развитие возможностей FSM**: В будущем мы можем расширить FSM, добавив поддержку `guards` (условия на переходах) и `effects` (побочные эффекты при входе/выходе из состояния), как это отмечено в `fsm.md`.

4.  **Поддержка NLU (2-е поколение)**: Мы осознанно отложили внедрение Natural Language Understanding. Текущая система маршрутизации основана на явных событиях (`event`). В будущем, NLU-модуль сможет анализировать текст пользователя и преобразовывать его в такие события.

5.  **Строгое соблюдение Bounded Contexts**: Мы продолжим придерживаться чистоты архитектуры. Например, `bot-persona` отвечает за *поведение* бота, в то время как история сообщений, логи и аналитика должны быть вынесены в отдельные ограниченные контексты (`Chat`, `Analytics`).
