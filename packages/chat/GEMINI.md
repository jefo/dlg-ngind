# Контекст проекта: `chat`

Этот документ описывает архитектуру, обязанности и цели ограниченного контекста `chat`.

## 1. О нас: Что это за контекст?

**`chat`** — это ограниченный контекст (Bounded Context), отвечающий за **абстракцию над транспортным уровнем** обмена сообщениями. Его главная задача — унифицировать взаимодействие с различными платформами (Telegram, Slack, WhatsApp и т.д.), предоставляя единый интерфейс для остальной части системы.

Ключевые обязанности:
- **Прием входящих сообщений**: Адаптеры для конкретных платформ (например, `telegram.adapter`) слушают внешние API, преобразуют входящие данные в независимый от платформы формат и передают их в ядро приложения.
- **Отправка исходящих сообщений**: Ядро приложения отправляет сообщения через выходные порты, а адаптеры преобразуют их в формат, понятный конкретной платформе.
- **Управление жизненным циклом чата и участников**: Контекст отвечает за создание и ведение сущностей `Chat` (канал общения) и `Persona` (участник).

## 2. Архитектура: Как это работает?

Контекст построен в соответствии с принципами **Гексагональной архитектуры (Порты и Адаптеры)**, что обеспечивает слабую связанность и высокую тестируемость.

### Уровни Архитектуры

1.  **Домен (`src/domain`)**:
    - **Сущности (Entities)**: `Chat`, `Persona`, `Message`. Это чистые доменные объекты, не содержащие логики инфраструктуры. Их идентификаторы имеют формат `<platform>:<id>` (например, `telegram:123456`), что позволяет хранить участников из разных сетей в одной системе.
    - **Порты данных (Data Ports)**: Абстрактные контракты для сохранения и извлечения доменных сущностей (например, `findChatByIdPort`, `savePersonaPort`).

2.  **Приложение (`src/application`)**:
    - **Use Cases**: Оркестрируют бизнес-логику. Ключевой use case — `receiveIncomingMessageUseCase`, который при получении сообщения создает `Persona` и `Chat`, если они не существуют, и передает управление `sendMessageUseCase`.
    - **Порты Приложения (Application Ports)**:
        - **Входные (Driving Ports)**: `startListeningPort`, `stopListeningPort` — контракты для управления жизненным циклом адаптеров платформ.
        - **Выходные (Driven/Output Ports)**: `messageSentOutPort` — контракт для уведомления внешнего мира (например, адаптера платформы) об отправке сообщения.

3.  **Инфраструктура (`src/infrastructure`)**:
    - **Адаптеры Платформ (`platform`)**: Конкретные реализации портов для взаимодействия с внешними сервисами. `telegram.adapter` реализует `startListeningPort` через long-polling к API Telegram.
    - **Адаптеры Персистенции (`persistence`)**: Реализации портов данных. На данный момент используется `in-memory.adapters` для хранения в памяти.
    - **Composition Root (`src/composition.ts`)**: Точка сборки, где порты связываются с их конкретными реализациями-адаптерами.

### Ключевой флоу: Жизненный цикл входящего сообщения

1.  **Adapter**: `telegram.adapter` получает обновление от Telegram API.
2.  **Transformation**: Адаптер преобразует данные Telegram в платформо-независимый DTO.
3.  **Use Case Invocation**: Адаптер вызывает `receiveIncomingMessageUseCase` с этим DTO.
4.  **Core Logic**:
    - Use case через порты проверяет наличие `Persona` и `Chat`.
    - Если их нет, он создает и сохраняет новые сущности.
    - Затем он вызывает `sendMessageUseCase`.
5.  **Domain Logic**: `sendMessageUseCase` создает сущность `Message`, сохраняет ее и вызывает выходной порт `messageSentOutPort`.
6.  **Output Adapter**: Адаптер, подписанный на `messageSentOutPort`, получает DTO сообщения, преобразует его в запрос к Telegram API и отправляет ответ пользователю.

## 3. Куда мы идем: Следующие шаги

1.  **Расширение поддержки платформ**: Добавление новых адаптеров для других мессенджеров (Slack, Viber, Discord).
2.  **Надежная персистенция**: Замена `in-memory` адаптеров на реализации для работы с реальной базой данных (например, PostgreSQL).
3.  **Обработка ошибок и отказоустойчивость**: Внедрение более надежных механизмов обработки ошибок в адаптерах и use cases.
