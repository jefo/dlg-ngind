# Архитектура контекста `bot-ui`

## 1. Обзор архитектуры

Контекст `bot-ui` следует принципам **Domain-Driven Design** и **Гексагональной архитектуры** с использованием фреймворка **SotaJS**.

```
bot-ui/
├── src/
│   ├── domain/          # Доменная модель
│   │   ├── components/  # Компоненты UI (Value Objects)
│   │   └── views/       # Представления (Aggregates)
│   ├── application/     # Бизнес-логика (Use Cases)
│   └── infrastructure/  # Реализации портов (Adapters)
└── tests/               # Тесты
```

## 2. Доменная модель

### Компоненты (Components)
Реализованы как **Объекты-значения (Value Objects)**, что гарантирует их неизменяемость и структурное равенство.

**Базовые компоненты:**
- `MessageComponent` — Текстовые сообщения с вариантами стилей
- `ButtonComponent` — Интерактивные кнопки с действиями
- `CardComponent` — Карточки с заголовком, описанием и действиями
- Расширяемая система для новых типов компонентов

### Представления (Views)
Реализованы как **Агрегаты (Aggregates)**, что обеспечивает транзакционную целостность компоновки интерфейса.

**Свойства представления:**
- `id` — Уникальный идентификатор
- `name` — Имя представления для идентификации
- `layout` — Тип компоновки (vertical, horizontal, grid)
- `components` — Список компонентов в представлении

**Вычисляемые свойства:**
- `componentCount` — Количество компонентов в представлении

**Действия:**
- `addComponent(component)` — Добавление компонента
- `removeComponent(componentId)` — Удаление компонента
- `updateLayout(layout)` — Изменение типа компоновки

## 3. Прикладной уровень (Application Layer)

### Use Cases
Центральная точка входа для бизнес-операций. В SotaJS use cases следуют принципу "ничего не возвращать", а вместо этого уведомлять о результатах через **выходные порты**.

**Основной use case:**
- `renderViewUseCase` — Оркестрирует процесс рендеринга представления

### DTO (Data Transfer Objects)
- `RenderViewInput` — Входные данные для рендеринга
- `HydratedView` — Результат рендеринга

## 4. Инфраструктурный уровень

### Порты (Ports)
Абстрактные контракты для взаимодействия с внешними системами:

**Основные порты:**
- `renderViewPort` — Контракт для движка рендеринга
- `viewRenderedOutPort` — Уведомление об успешном рендеринге
- `viewRenderingFailedOutPort` — Уведомление о неудаче рендеринга

### Адаптеры (Adapters)
Конкретные реализации портов:

**Адаптер рендеринга:**
- `renderViewAdapter` — Реализация гидратации компонентов с заменой плейсхолдеров

## 5. Поток выполнения

### Рендеринг представления:

1. **Вызов из внешнего контекста:**
   ```typescript
   await renderViewUseCase({
     view: view.state,
     context: { name: 'John' }
   });
   ```

2. **Внутри use case:**
   - Получение依赖остей через `usePort()`
   - Вызов движка рендеринга
   - Уведомление о результате через выходные порты

3. **В адаптере рендеринга:**
   - Гидратация компонентов
   - Замена `{{name}}` на `"John"`
   - Возврат результата

## 6. Принципы разработки

### Неизменяемость
Все доменные объекты неизменяемы. Методы возвращают новые экземпляры вместо модификации существующих.

### Явные зависимости
Все внешние зависимости объявляются через порты и запрашиваются через `usePort()`.

### Тестируемость
Бизнес-логика полностью изолирована и может быть протестирована без реальной инфраструктуры.

### Разделение ответственности
Четкое разделение между доменной логикой, оркестрацией и инфраструктурой.