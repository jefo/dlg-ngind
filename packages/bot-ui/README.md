# Контекст проекта: `bot-ui`

## 1. Общее описание

**`bot-ui`** — это ограниченный контекст (Bounded Context), отвечающий за **визуальное представление диалоговых интерфейсов** в чат-ботах. Он определяет, как будет выглядеть интерфейс бота и как пользователь будет с ним взаимодействовать.

Контекст представляет собой "UI-кит" или "движок рендеринга", который позволяет создавать богатые интерфейсы для диалоговых систем независимо от платформы (Telegram, Slack, Web и т.д.).

## 2. Бизнес-ценность

### Основные функции контекста:

1. **Библиотека компонентов интерфейса** — Единый источник правды о том, из каких элементов может состоять интерфейс бота:
   - Сообщения (Messages) с различными стилями
   - Кнопки действий (Buttons) 
   - Карточки с информацией (Cards)
   - Карточки товаров (Product Cards) с изображением, описанием и ценой
   - Карточки ботов (Bot Product Cards) с функциями, стоимостью и интеграциями
   - Галереи изображений (Carousels)
   - И другие UI-элементы

2. **Компоновка интерфейсов (Views)** — Возможность создавать сложные экраны, комбинируя компоненты в различные layout'ы:
   - Вертикальные и горизонтальные списки
   - Сетки элементов
   - Комбинированные представления

3. **Движок персонализации** — Механизм подстановки персональных данных пользователя в шаблоны интерфейса:
   - Персонализация приветствий
   - Динамическое отображение информации
   - Адаптация интерфейса под контекст диалога

4. **Платформо-независимый рендеринг** — Подготовка универсального описания интерфейса, которое затем может быть адаптировано под любую платформу.

## 3. Взаимодействие с другими контекстами

### Входящие зависимости:
- **`bot-persona`** — Запрашивает рендеринг интерфейсов для отображения ответов бота пользователю

### Исходящие зависимости:
- **Презентеры платформ** — Получают универсальное описание интерфейса и адаптируют его под конкретные платформы (Telegram, Slack, Web)

## 4. Архитектурный подход

Контекст разработан в соответствии с принципами **Domain-Driven Design** и **Гексагональной архитектуры** с использованием фреймворка **SotaJS**:

### Доменная модель:
- **Компоненты** — Атомарные элементы интерфейса (Value Objects)
- **Представления** — Композитные структуры, определяющие компоновку интерфейса (Aggregates)

### Поток управления:
1. Внешний контекст запрашивает рендеринг представления
2. Контекст получает шаблон и данные для персонализации
3. Движок рендеринга гидратирует шаблон актуальными данными
4. Результат возвращается в виде универсального описания интерфейса

## 5. Техническая архитектура

### Уровни архитектуры:

1. **Домен (`src/domain`):**
   - **Компоненты (`components`):** Схемы и типы для всех UI-компонентов как объектов-значений
   - **Представления (`view.aggregate.ts`):** Агрегаты, определяющие компоновку компонентов и layout
   - **Порты (`ports.ts`):** Абстрактные контракты для движка шаблонизации и выходные порты

2. **Приложение (`src/application`):**
   - **Use Cases:** Основной use case — `renderViewUseCase`, который оркестрирует процесс рендеринга

3. **Инфраструктура (`src/infrastructure`):**
   - **Адаптеры (`adapters`):** Конкретная реализация порта рендеринга

### Специализированные компоненты:

1. **MessageComponent** - текстовое сообщение с вариантами оформления
2. **ButtonComponent** - интерактивная кнопка с действием
3. **CardComponent** - карточка с заголовком, описанием и изображением
4. **ProductCardComponent** - карточка товара с изображением, описанием, ценой и кнопкой "подробнее"
5. **BotProductCardComponent** - карточка бота с названием модели, функциями, стоимостью, интеграциями и кнопкой "подробнее"

## 6. Преимущества подхода

### Для бизнеса:
- **Гибкость интерфейсов** — Возможность быстро создавать и модифицировать интерфейсы ботов
- **Консистентность** — Единый подход к построению интерфейсов во всех каналах
- **Персонализация** — Автоматическая адаптация интерфейсов под пользователей

### Для разработки:
- **Тестируемость** — Все бизнес-правила изолированы и покрыты тестами
- **Расширяемость** — Простое добавление новых типов компонентов и layout'ов
- **Поддерживаемость** — Четкое разделение ответственности между слоями

## 7. Использование

Пример использования контекста:

```typescript
import { View, MessageComponent, ButtonComponent, ProductCardComponent, BotProductCardComponent } from '@dlg-ngind/bot-ui';
import { renderViewUseCase } from '@dlg-ngind/bot-ui/application';

// Создание компонентов
const message = MessageComponent.create({
  id: 'msg1',
  type: 'message',
  props: {
    text: 'Hello, {{name}}!',
    variant: 'info'
  }
});

// Создание карточки товара
const productCard = ProductCardComponent.create({
  id: 'product1',
  type: 'product-card',
  props: {
    title: 'Ноутбук',
    description: 'Мощный игровой ноутбук',
    imageUrl: 'https://example.com/laptop.jpg',
    price: 99999,
    currency: 'RUB',
    actionText: 'Подробнее',
    action: 'view_product'
  }
});

// Создание карточки бота
const botProductCard = BotProductCardComponent.create({
  id: 'bot1',
  type: 'bot-product-card',
  props: {
    modelName: 'Sales Assistant Pro',
    features: [
      'Автоматическая квалификация лида',
      'Интеграция с CRM',
      'Многоканальная поддержка'
    ],
    price: 29900,
    currency: 'RUB',
    integrations: [
      'Telegram',
      'WhatsApp',
      'Slack',
      'CRM Systems'
    ],
    actionText: 'Подробнее',
    action: 'view_bot_details'
  }
});

const button = ButtonComponent.create({
  id: 'btn1',
  type: 'button',
  props: {
    text: 'Click me',
    action: 'click'
  }
});

// Создание представления
const view = View.create({
  id: 'view1',
  name: 'greeting',
  layout: 'vertical',
  components: [message, productCard, botProductCard, button]
});

// Рендеринг представления
await renderViewUseCase({
  view: view.state,
  context: { name: 'John' }
});
```